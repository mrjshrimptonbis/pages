import React, { useState, useEffect, useRef, useCallback } from 'react';

// --- Icons ---
const Icons = {
    Play: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
    ),
    Zap: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
    ),
    Volume2: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
    ),
    VolumeX: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
    ),
    Keyboard: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect><line x1="6" y1="8" x2="6" y2="8"></line><line x1="10" y1="8" x2="10" y2="8"></line><line x1="14" y1="8" x2="14" y2="8"></line><line x1="18" y1="8" x2="18" y2="8"></line><line x1="6" y1="12" x2="6" y2="12"></line><line x1="10" y1="12" x2="10" y2="12"></line><line x1="14" y1="12" x2="14" y2="12"></line><line x1="18" y1="12" x2="18" y2="12"></line><line x1="6" y1="16" x2="6" y2="16"></line><line x1="10" y1="16" x2="14" y2="16"></line><line x1="18" y1="16" x2="18" y2="16"></line></svg>
    ),
    Binary: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><rect x="14" y="14" width="4" height="6" rx="2"></rect><rect x="6" y="4" width="4" height="6" rx="2"></rect><path d="M6 20h4"></path><path d="M14 10h4"></path><path d="M6 14h2v6"></path><path d="M14 4h2v6"></path></svg>
    ),
    Hash: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></svg>
    ),
    Delete: (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line></svg>
    )
};

// --- Sound Engine ---
const SoundEngine = {
    ctx: null,
    enabled: true,
    musicNode: null,
    nextNoteTime: 0,
    tempo: 120,
    isPlaying: false,
    
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },

    playTone(freq, type, duration, vol = 0.1, slide = 0) {
        if (!this.ctx || !this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if (slide !== 0) {
             osc.frequency.exponentialRampToValueAtTime(freq + slide, this.ctx.currentTime + duration);
        }
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },

    playShoot() {
        this.playTone(880, 'sawtooth', 0.1, 0.08, -600);
        this.playTone(440, 'square', 0.1, 0.04, -200);
    },

    playSpawn() {
        this.playTone(300, 'sine', 0.1, 0.03);
    },

    playLand() {
        if (!this.ctx || !this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    },

    playError() {
        this.playTone(150, 'sawtooth', 0.15, 0.15);
        setTimeout(() => this.playTone(100, 'sawtooth', 0.15, 0.15), 100);
    },

    playType() {
        if (!this.ctx || !this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.02, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.03);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.03);
    },

    playLevelUp() {
        const now = this.ctx.currentTime;
        [0, 0.1, 0.2, 0.4].forEach((t, i) => {
            const notes = [440, 554, 659, 880];
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(notes[i], now + t);
            gain.gain.setValueAtTime(0.1, now + t);
            gain.gain.linearRampToValueAtTime(0, now + t + 0.3);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(now + t);
            osc.stop(now + t + 0.3);
        });
    },

    playGameOver() {
        this.playTone(200, 'sawtooth', 1.5, 0.2, -190);
        this.stopMusic();
    },

    // --- Music Sequencer ---
    startMusic() {
        if (!this.ctx || !this.enabled || this.isPlaying) return;
        this.isPlaying = true;
        this.nextNoteTime = this.ctx.currentTime;
        this.scheduler();
    },

    stopMusic() {
        this.isPlaying = false;
        if (this.timeoutId) clearTimeout(this.timeoutId);
    },

    scheduler() {
        if (!this.isPlaying) return;
        while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
            this.scheduleNote(this.nextNoteTime);
            this.nextNoteTime += 60.0 / this.tempo; // 1 beat
        }
        this.timeoutId = setTimeout(() => this.scheduler(), 25);
    },

    scheduleNote(time) {
        const beat = Math.floor(time * (this.tempo / 60)) % 16;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        let freq = 0;
        
        if (beat % 4 === 0) freq = 65.41; // C2
        if (beat === 14) freq = 77.78; // Eb2
        if (beat === 15) freq = 87.31; // F2
        
        if (freq > 0) {
            osc.frequency.setValueAtTime(freq, time);
            osc.type = 'square';
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(400, time);
            filter.frequency.exponentialRampToValueAtTime(100, time + 0.2);
            gain.gain.setValueAtTime(0.08, time); 
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(time);
            osc.stop(time + 0.4);
        }
    }
};

// --- Game Constants ---
const COLS = 4;
const BLOCK_HEIGHT = 72; 
const CONTAINER_HEIGHT = 600; 

const BASES = {
    2: { id: 2, label: 'BIN', color: 'text-emerald-400', bg: 'bg-emerald-950/95', border: 'border-emerald-500/50', accent: 'bg-emerald-500', glow: 'shadow-[0_0_15px_rgba(16,185,129,0.3)]' },
    10: { id: 10, label: 'DEC', color: 'text-cyan-400', bg: 'bg-cyan-950/95', border: 'border-cyan-500/50', accent: 'bg-cyan-500', glow: 'shadow-[0_0_15px_rgba(6,182,212,0.3)]' },
    16: { id: 16, label: 'HEX', color: 'text-fuchsia-400', bg: 'bg-fuchsia-950/95', border: 'border-fuchsia-500/50', accent: 'bg-fuchsia-500', glow: 'shadow-[0_0_15px_rgba(217,70,239,0.3)]' }
};

const generateProblem = (level) => {
    const types = [];
    types.push({ from: 2, to: 10, min: 0, max: 15 });
    if (level >= 2) types.push({ from: 10, to: 2, min: 0, max: 31 });
    if (level >= 3) types.push({ from: 2, to: 16, min: 0, max: 15 });
    if (level >= 4) types.push({ from: 16, to: 2, min: 0, max: 15 });
    if (level >= 5) types.push({ from: 10, to: 16, min: 0, max: 15 });
    if (level >= 6) types.push({ from: 16, to: 10, min: 0, max: 15 });
    if (level >= 7) {
        types.push({ from: 2, to: 16, min: 16, max: 255 });
        types.push({ from: 16, to: 2, min: 16, max: 255 });
        types.push({ from: 10, to: 16, min: 16, max: 255 });
        types.push({ from: 16, to: 10, min: 16, max: 255 });
    }

    const type = types[Math.floor(Math.random() * types.length)];
    const value = Math.floor(Math.random() * (type.max - type.min + 1)) + type.min;
    
    let displayVal = value.toString(type.from).toUpperCase();
    let answer = value.toString(type.to).toUpperCase();

    if (type.from === 2) {
        const bitLength = value > 15 ? 8 : 4;
        displayVal = displayVal.padStart(bitLength, '0');
        const matches = displayVal.match(/.{1,4}(?=(.{4})*$)/g);
        if (matches) displayVal = matches.join(' ');
    }

    return {
        id: Math.random().toString(36).substr(2, 9),
        value,
        fromBase: type.from,
        toBase: type.to,
        displayVal,
        answer,
        x: 0,
        y: -BLOCK_HEIGHT - 20,
        col: 0,
        status: 'falling', // falling, landed, destroying
        landed: false
    };
};

// --- Components ---

const Instructions = ({ onStart }) => (
    <div className="flex flex-col items-center justify-center h-full w-full max-w-2xl mx-auto p-6 text-center space-y-6 animate-fade-in z-30 relative">
        <div className="space-y-4">
            <h1 className="text-6xl font-black tracking-tighter text-white drop-shadow-[0_0_15px_rgba(6,182,212,0.8)] neon-text">
                BASE STACK
            </h1>
            <p className="text-cyan-200 text-sm font-mono tracking-widest bg-black/40 px-4 py-1 rounded inline-block border border-cyan-500/30">
                DATA CONVERSION PROTOCOL
            </p>
        </div>

        <div className="grid grid-cols-1 gap-4 text-left w-full max-w-lg bg-slate-900/90 p-6 rounded-xl border border-slate-600 shadow-[0_0_50px_rgba(0,0,0,0.5)]">
            <div className="flex items-center gap-3 text-cyan-400 mb-2 border-b border-slate-700 pb-2">
                <Icons.Keyboard className="w-6 h-6" />
                <h3 className="font-bold text-lg uppercase tracking-wider">Protocol</h3>
            </div>
            
            <div className="space-y-4 text-sm text-slate-300">
                <p className="text-xs text-slate-500 uppercase tracking-widest font-bold mb-2">Objective: Prevent Stack Overflow</p>
                <div className="flex items-center justify-between bg-black/30 p-2 rounded border border-slate-700">
                    <div className="flex items-center gap-2">
                        <span className="text-[10px] text-emerald-500 font-bold">BIN</span>
                        <span className="font-mono text-emerald-300 font-bold text-lg">101</span>
                    </div>
                    <span className="text-slate-500 text-xs">CONVERT TO DEC</span>
                    <div className="font-mono text-white bg-slate-700 px-2 rounded animate-pulse">5</div>
                </div>
            </div>
        </div>

        <button 
            onClick={() => { SoundEngine.init(); onStart(); }}
            className="group relative px-12 py-5 bg-cyan-600 hover:bg-cyan-500 text-white font-black text-xl rounded-none border-2 border-cyan-400 hover:border-white transition-all hover:shadow-[0_0_30px_rgba(6,182,212,0.6)] skew-x-[-10deg]"
        >
            <span className="flex items-center gap-3 relative z-10 skew-x-[10deg]">
                <Icons.Play fill="currentColor" className="w-6 h-6" /> 
                INITIATE
            </span>
        </button>
    </div>
);

const Block = ({ data }) => {
    const fromStyle = BASES[data.fromBase];
    const toStyle = BASES[data.toBase];
    const isDestroying = data.status === 'destroying';
    const isLong = data.displayVal.length > 5;
    
    return (
        <div 
            className={`
                absolute w-[92%] left-[4%] rounded-md border-2 
                flex flex-col overflow-hidden shadow-lg transition-transform will-change-transform
                ${fromStyle.bg} ${fromStyle.border} ${fromStyle.glow}
                ${isDestroying ? 'animate-destroy z-50' : 'block-enter z-10'}
            `}
            style={{ top: data.y, height: BLOCK_HEIGHT - 4 }}
        >
            <div className="h-5 w-full flex items-center justify-between px-2 bg-black/40 text-[9px] font-black tracking-[0.2em] uppercase text-white/40">
                <span>{fromStyle.label}</span>
                <span>ID::{data.id.slice(0,3)}</span>
            </div>
            <div className={`flex-1 flex items-center justify-center font-mono font-black ${isLong ? 'text-lg' : 'text-2xl'} tracking-tighter ${fromStyle.color} drop-shadow-md whitespace-nowrap`}>
                {data.displayVal}
            </div>
            <div className={`h-5 w-full flex items-center justify-center gap-2 text-[10px] font-bold uppercase ${toStyle.accent} text-white shadow-inner`}>
                <span className="opacity-80">TO</span>
                <span className="bg-black/30 px-1 rounded text-white">{toStyle.label}</span>
            </div>
        </div>
    );
};

const Particle = ({ data }) => (
    <div 
        className="absolute rounded-full pointer-events-none"
        style={{
            left: `${data.x}%`,
            top: data.y,
            width: data.size,
            height: data.size,
            backgroundColor: data.color,
            opacity: data.life,
            transform: `scale(${data.life})`,
            zIndex: 60
        }}
    />
);

const BitHelper = ({ onUpdate, currentVal, onInputFocus }) => {
    const [bits, setBits] = useState(new Array(8).fill(false));

    useEffect(() => {
        if (/^[01]+$/.test(currentVal)) {
            if (currentVal === '') setBits(new Array(8).fill(false));
        } else if (currentVal === '') {
            setBits(new Array(8).fill(false));
        }
    }, [currentVal]);

    const toggleBit = (index) => {
        const newBits = [...bits];
        newBits[index] = !newBits[index];
        setBits(newBits);
        let binaryStr = newBits.map(b => b ? '1' : '0').join('');
        onUpdate(binaryStr);
        onInputFocus();
    };

    const placeValues = [128, 64, 32, 16, 8, 4, 2, 1];

    return (
        <div className="w-full h-full bg-slate-900/80 p-2 rounded-lg border border-slate-700 grid grid-cols-8 gap-1">
            {bits.map((isOn, i) => (
                <button
                    key={i}
                    onClick={() => toggleBit(i)}
                    className={`flex flex-col items-center justify-center p-1 rounded transition-all duration-150 active:scale-95 ${isOn ? 'bg-emerald-600 border-emerald-400' : 'bg-slate-800 border-slate-700 hover:bg-slate-700'} border`}
                >
                    <span className={`text-[8px] font-bold ${isOn ? 'text-white' : 'text-slate-500'}`}>{placeValues[i]}</span>
                    <span className={`text-base font-mono font-bold leading-none ${isOn ? 'text-white' : 'text-slate-600'}`}>{isOn ? '1' : '0'}</span>
                </button>
            ))}
        </div>
    );
};

const HexHelper = ({ onAppend, onBackspace, onClear, onInputFocus }) => {
    const chars = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'];
    const handleAppend = (char) => { onAppend(char); onInputFocus(); };

    return (
        <div className="w-full h-full bg-slate-900/80 p-2 rounded-lg border border-slate-700 flex flex-col justify-between">
            <div className="grid grid-cols-8 gap-1 mb-1">
                {chars.map(char => (
                    <button key={char} onClick={() => handleAppend(char)} className="bg-slate-800 border border-slate-700 hover:bg-slate-700 hover:border-fuchsia-500/50 text-fuchsia-100 font-mono font-bold text-lg h-8 rounded transition-all active:scale-95 flex items-center justify-center">{char}</button>
                ))}
            </div>
            <div className="grid grid-cols-2 gap-2 mt-auto">
                 <button onClick={() => { onBackspace(); onInputFocus(); }} className="flex items-center justify-center gap-2 bg-slate-800/50 border border-red-900/50 hover:bg-red-900/30 text-red-200 font-bold py-1 rounded text-xs uppercase transition-colors"><Icons.Delete size={14} /> Backspace</button>
                 <button onClick={() => { onClear(); onInputFocus(); }} className="bg-slate-800 border border-slate-700 hover:bg-slate-700 text-slate-400 font-bold py-1 rounded uppercase text-xs transition-colors">Clear</button>
            </div>
        </div>
    );
};

// --- Main App Component ---
export default function App() {
    const [gameState, setGameState] = useState('menu');
    const [blocks, setBlocks] = useState([]);
    const [particles, setParticles] = useState([]);
    const [score, setScore] = useState(0);
    const [level, setLevel] = useState(1);
    const [inputValue, setInputValue] = useState('');
    const [shake, setShake] = useState(false);
    const [validInputFlash, setValidInputFlash] = useState(false);
    const [soundEnabled, setSoundEnabled] = useState(true);
    const [combo, setCombo] = useState(0);
    const [dangerCols, setDangerCols] = useState([]); // Array of col indices near full
    const [overflowCol, setOverflowCol] = useState(-1); // The column that killed you
    const [screenShake, setScreenShake] = useState(false);
    const [activeHelper, setActiveHelper] = useState('bin');
    
    const requestRef = useRef();
    const lastTimeRef = useRef();
    const spawnTimerRef = useRef(0);
    const comboTimerRef = useRef(null);
    const gameOverRef = useRef(false);
    const inputRef = useRef(null);

    const speedMultiplier = 1 + (level * 0.1);
    const spawnInterval = Math.max(900, 3200 - (level * 250)); 
    const baseFallSpeed = 40; 

    useEffect(() => { SoundEngine.enabled = soundEnabled; }, [soundEnabled]);

    useEffect(() => {
        const newLevel = Math.floor(score / 1200) + 1;
        if (newLevel !== level) {
            setLevel(newLevel);
            SoundEngine.playLevelUp();
        }
    }, [score]);

    // Global Keydown Handler for Enter
    useEffect(() => {
        const handleGlobalKeyDown = (e) => {
            if (e.key === 'Enter' && gameState === 'playing') checkAnswer();
        };
        window.addEventListener('keydown', handleGlobalKeyDown);
        return () => window.removeEventListener('keydown', handleGlobalKeyDown);
    }, [inputValue, gameState, blocks]); 

    const triggerScreenShake = () => {
        setScreenShake(true);
        setTimeout(() => setScreenShake(false), 200);
    };

    const update = useCallback((time) => {
        if (gameState !== 'playing') return;
        
        if (lastTimeRef.current === undefined) lastTimeRef.current = time;
        const deltaTime = time - lastTimeRef.current;
        lastTimeRef.current = time;

        spawnTimerRef.current += deltaTime;
        if (spawnTimerRef.current > spawnInterval) {
            spawnBlock();
            spawnTimerRef.current = 0;
        }

        // Particle Update
        setParticles(prev => prev.map(p => ({
            ...p,
            x: p.x + p.vx,
            y: p.y + p.vy,
            vy: p.vy + 0.1, // Gravity
            life: p.life - 0.02
        })).filter(p => p.life > 0));

        setBlocks(prevBlocks => {
            const liveBlocks = prevBlocks.filter(b => !(b.status === 'destroying' && b.destroyTimer <= 0));
            const nextBlocks = liveBlocks.map(b => {
                if (b.status === 'destroying') return { ...b, destroyTimer: b.destroyTimer - deltaTime };
                return { ...b };
            });

            const cols = [[], [], [], []];
            const activeBlocks = nextBlocks.filter(b => b.status !== 'destroying');
            activeBlocks.forEach(b => cols[b.col].push(b));
            cols.forEach(col => col.sort((a, b) => b.y - a.y)); // Index 0 is bottom-most

            let gameOver = false;
            let justLanded = false;
            let failingCol = -1;
            const newDangerCols = [];

            // Physics Loop
            cols.forEach((colBlocks, colIdx) => {
                let highestBlockY = CONTAINER_HEIGHT; // Reset per column

                for (let i = 0; i < colBlocks.length; i++) {
                    const block = colBlocks[i];
                    const floorY = CONTAINER_HEIGHT - BLOCK_HEIGHT;
                    let targetY;

                    if (i === 0) targetY = floorY;
                    else {
                        const blockBelow = colBlocks[i - 1];
                        targetY = blockBelow.y - BLOCK_HEIGHT - 4; 
                    }

                    if (block.y < targetY) {
                        block.y += (baseFallSpeed * speedMultiplier * (deltaTime / 1000));
                        if (block.y >= targetY) {
                            block.y = targetY; 
                            if (!block.landed) {
                                block.landed = true;
                                justLanded = true;
                            }
                        }
                    } else {
                        block.y = targetY; 
                        if (!block.landed) {
                            block.landed = true;
                            justLanded = true;
                        }
                    }

                    // CRITICAL FIX: Only count LANDED blocks for the stack height.
                    // New spawning blocks (falling from top) should NOT trigger Game Over.
                    if (block.landed && block.y < highestBlockY) {
                        highestBlockY = block.y;
                    }
                }

                // Check Danger (Near Top)
                if (highestBlockY < 150) newDangerCols.push(colIdx);

                // Check Game Over (Overflows Top)
                // Use a strict threshold (e.g., 0)
                if (highestBlockY <= 0) {
                    gameOver = true;
                    failingCol = colIdx;
                }
            });

            if (justLanded) {
                SoundEngine.playLand();
                triggerScreenShake();
            }

            setDangerCols(newDangerCols);

            if (gameOver) {
                setGameState('gameover');
                setOverflowCol(failingCol);
                SoundEngine.playGameOver();
                return prevBlocks; 
            }

            return nextBlocks;
        });

        if (!gameOverRef.current) requestRef.current = requestAnimationFrame(update);
    }, [gameState, level, speedMultiplier, spawnInterval]);

    useEffect(() => { gameOverRef.current = (gameState === 'gameover'); }, [gameState]);

    useEffect(() => {
        if (gameState === 'playing') {
            requestRef.current = requestAnimationFrame(update);
            SoundEngine.startMusic();
            setTimeout(() => { if(inputRef.current) inputRef.current.focus(); }, 100);
        } else {
            cancelAnimationFrame(requestRef.current);
            lastTimeRef.current = undefined;
            SoundEngine.stopMusic();
        }
        return () => { cancelAnimationFrame(requestRef.current); SoundEngine.stopMusic(); }
    }, [gameState, update]);

    const spawnBlock = () => {
        setBlocks(prev => {
            const colCounts = [0, 0, 0, 0];
            prev.forEach(b => { if(b.status !== 'destroying') colCounts[b.col]++ });
            // Don't spawn in full columns to be fair, unless all are full
            const validCols = colCounts.map((count, idx) => count < 8 ? idx : -1).filter(idx => idx !== -1);
            if (validCols.length === 0) return prev; // All full, let game over logic handle it

            const col = validCols[Math.floor(Math.random() * validCols.length)];
            const newBlock = generateProblem(level);
            newBlock.col = col;
            
            SoundEngine.playSpawn();
            return [...prev, newBlock];
        });
    };

    const spawnParticles = (block) => {
        const newParticles = [];
        const color = block.fromBase === 2 ? '#34d399' : block.fromBase === 10 ? '#22d3ee' : '#e879f9';
        // Approximate center of block in %
        const centerX = (block.col * 25) + 12.5;
        
        for(let i=0; i<8; i++) {
            newParticles.push({
                id: Math.random(),
                x: centerX + (Math.random() * 10 - 5), 
                y: block.y + BLOCK_HEIGHT/2,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 5,
                life: 1.0,
                color: color,
                size: Math.random() * 6 + 2
            });
        }
        setParticles(prev => [...prev, ...newParticles]);
    };

    const startGame = () => {
        setBlocks([]);
        setParticles([]);
        setScore(0);
        setLevel(1);
        setCombo(0);
        setInputValue('');
        setDangerCols([]);
        setOverflowCol(-1);
        spawnTimerRef.current = -1500; // Small delay before first spawn
        lastTimeRef.current = undefined;
        gameOverRef.current = false;
        setGameState('playing');
        // Initial spawn happens in loop after timer passes 0
    };

    const handleInput = (e) => {
        const val = e.target.value.toUpperCase().trim();
        if (/^[0-9A-F]*$/.test(val)) {
            setInputValue(val);
            SoundEngine.playType();
        }
    };
    const focusInput = () => { if (inputRef.current) inputRef.current.focus(); };
    const handleBitUpdate = (binaryStr) => {
        let val = binaryStr.replace(/^0+(?!$)/, '');
        setInputValue(val);
        SoundEngine.playType();
    };
    const handleHexAppend = (char) => { setInputValue(prev => prev + char); SoundEngine.playType(); };
    const handleBackspace = () => { setInputValue(prev => prev.slice(0, -1)); SoundEngine.playType(); };

    const checkAnswer = () => {
        if (!inputValue) return;
        const matches = blocks.filter(b => {
             if (b.status === 'destroying') return false;
             if (b.toBase === 2) return parseInt(b.answer, 2) === parseInt(inputValue, 2);
             return b.answer === inputValue;
        });

        if (matches.length > 0) {
            const target = matches.reduce((prev, current) => (prev.y > current.y) ? prev : current);
            const points = (100 * level) + (combo * 25);
            
            spawnParticles(target);

            setBlocks(prev => prev.map(b => {
                if (b.id === target.id) return { ...b, status: 'destroying', destroyTimer: 250 };
                return b;
            }));
            
            setScore(prev => prev + points);
            setInputValue('');
            SoundEngine.playShoot();
            setValidInputFlash(true);
            setTimeout(() => setValidInputFlash(false), 200);
            setCombo(prev => prev + 1);
            if (comboTimerRef.current) clearTimeout(comboTimerRef.current);
            comboTimerRef.current = setTimeout(() => setCombo(0), 2000);
        } else {
            SoundEngine.playError();
            setShake(true);
            setCombo(0);
            setTimeout(() => setShake(false), 300);
            setInputValue('');
        }
    };

    return (
        <div className={`
            min-h-screen bg-[#020610] text-slate-200 flex flex-col items-center justify-center p-2 sm:p-4 
            overflow-hidden select-none font-sans transition-transform duration-100
            ${screenShake ? 'translate-x-[2px] translate-y-[2px]' : ''}
        `}>
            <style>{`
                @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&display=swap');
                body { font-family: 'JetBrains Mono', monospace; }
                .block-enter { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
                .animate-destroy { animation: destroyBlock 0.25s forwards ease-out; }
                .neon-text { text-shadow: 0 0 10px rgba(56, 189, 248, 0.5); }
                @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
                @keyframes destroyBlock { 0% { transform: scale(1); filter: brightness(2) hue-rotate(90deg); } 50% { transform: scale(1.2); opacity: 0.8; } 100% { transform: scale(0); opacity: 0; } }
                @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-8px) rotate(-1deg); border-color: #ef4444; } 75% { transform: translateX(8px) rotate(1deg); border-color: #ef4444; } }
                .shake-anim { animation: shake 0.3s ease-in-out; }
                .scanline { background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1)); background-size: 100% 4px; pointer-events: none; }
                .danger-col { background: linear-gradient(to bottom, rgba(239, 68, 68, 0.2), transparent); animation: pulseDanger 1s infinite; }
                .overflow-col { background: linear-gradient(to bottom, rgba(239, 68, 68, 0.6), rgba(239, 68, 68, 0.1)); }
                @keyframes pulseDanger { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
            `}</style>

            <div className="fixed inset-0 scanline z-50 opacity-20 pointer-events-none"></div>
            <div className="fixed inset-0 radial-gradient(circle, transparent 60%, black 100%) z-40 pointer-events-none"></div>
            <div className="fixed inset-0 z-0 opacity-30 pointer-events-none overflow-hidden">
                <div className={`absolute top-[-20%] left-[-10%] w-[50%] h-[50%] bg-cyan-900/30 rounded-full blur-[100px] transition-colors duration-1000 ${dangerCols.length > 0 ? 'bg-red-900/50' : ''}`}></div>
                <div className="absolute bottom-[-10%] right-[-10%] w-[60%] h-[60%] bg-blue-900/20 rounded-full blur-[120px]"></div>
            </div>

            {/* HUD */}
            <div className="relative w-full max-w-lg flex items-end justify-between mb-4 z-20 px-2">
                <div className="flex gap-4">
                    <div className="flex flex-col">
                        <span className="text-[10px] text-slate-500 font-bold tracking-widest uppercase">Score</span>
                        <span className="text-3xl font-black text-white leading-none tracking-tight">{score.toLocaleString()}</span>
                    </div>
                    <div className="flex flex-col pl-4 border-l border-slate-800">
                        <span className="text-[10px] text-slate-500 font-bold tracking-widest uppercase">Level</span>
                        <span className="text-3xl font-black text-cyan-400 leading-none">{level}</span>
                    </div>
                </div>
                <div className="flex flex-col items-end">
                    <div className="flex items-center gap-2 mb-1">
                        <button onClick={() => setSoundEnabled(!soundEnabled)} className="text-slate-500 hover:text-white transition-colors">{soundEnabled ? <Icons.Volume2 size={18} /> : <Icons.VolumeX size={18} />}</button>
                    </div>
                    <div className={`text-emerald-400 font-black text-xl italic transition-all duration-200 ${combo > 1 ? 'opacity-100 translate-y-0 scale-110' : 'opacity-0 translate-y-2 scale-100'}`}>{combo}x COMBO</div>
                </div>
            </div>

            {/* Game Container */}
            <div className={`
                relative w-full max-w-lg bg-[#0a0f1d] rounded-t-xl border-x-4 border-t-4
                overflow-hidden shadow-2xl transition-colors duration-500
                ${dangerCols.length > 0 ? 'border-red-500/50 shadow-[0_0_30px_rgba(239,68,68,0.2)]' : 'border-slate-700 shadow-[0_0_30px_rgba(0,0,0,0.5)]'}
            `} style={{ height: CONTAINER_HEIGHT }}>
                
                {/* Visual Columns Layer for Overflow/Danger */}
                <div className="absolute inset-0 grid grid-cols-4 z-0 pointer-events-none">
                    {[0, 1, 2, 3].map(i => (
                        <div key={i} className={`
                            border-r border-slate-800/30 h-full flex flex-col justify-end items-center pb-2 transition-colors duration-300
                            ${overflowCol === i ? 'overflow-col' : dangerCols.includes(i) ? 'danger-col' : ''}
                        `}>
                            <span className="text-[9px] text-slate-800 font-bold tracking-widest">COL 0{i+1}</span>
                        </div>
                    ))}
                </div>

                {/* Blocks Layer */}
                {gameState !== 'menu' && (
                    <div className="absolute inset-0 w-full h-full z-10">
                        {blocks.map(block => {
                            const left = `${block.col * 25}%`;
                            return (
                                <div key={block.id} style={{ left, width: '25%', height: '100%', position: 'absolute', top: 0, pointerEvents: 'none' }}>
                                    <Block data={block} />
                                </div>
                            );
                        })}
                    </div>
                )}
                
                {/* Particles Layer */}
                <div className="absolute inset-0 w-full h-full z-20 pointer-events-none">
                    {particles.map(p => <Particle key={p.id} data={p} />)}
                </div>

                {/* Screens */}
                {gameState === 'menu' && <Instructions onStart={startGame} />}
                {gameState === 'gameover' && (
                    <div className="absolute inset-0 z-50 bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center p-6 text-center animate-fade-in">
                        <Icons.Zap className="w-20 h-20 text-red-500 mb-4 animate-bounce drop-shadow-[0_0_15px_red]" />
                        <h2 className="text-5xl font-black text-white mb-2 tracking-tighter drop-shadow-[0_0_10px_rgba(239,68,68,0.5)]">STACK OVERFLOW</h2>
                        <p className="text-red-400/80 mb-8 font-mono tracking-widest text-xs border border-red-500/30 px-3 py-1 rounded">MEMORY LIMIT EXCEEDED â€¢ COL 0{overflowCol + 1} FAILED</p>
                        <div className="w-full max-w-xs bg-slate-900/80 p-6 rounded-xl border border-slate-700 mb-8 shadow-2xl">
                            <div className="flex justify-between items-end border-b border-slate-700 pb-2 mb-2">
                                <span className="text-xs text-slate-500 uppercase">Score</span>
                                <span className="text-2xl font-mono text-white">{score}</span>
                            </div>
                            <div className="flex justify-between items-end mb-4">
                                <span className="text-xs text-slate-500 uppercase">Max Combo</span>
                                <span className="text-2xl font-mono text-emerald-400">{combo}</span>
                            </div>
                        </div>
                        <button onClick={startGame} className="px-10 py-4 bg-white text-black font-black uppercase tracking-wider hover:bg-cyan-400 transition-colors shadow-xl rounded-sm hover:skew-x-[-10deg] transform duration-200">Reboot System</button>
                    </div>
                )}
            </div>

            {/* Input Bar */}
            <div className="w-full max-w-lg bg-slate-800 rounded-b-xl border-x-4 border-b-4 border-slate-700 p-2 z-20 shadow-xl">
                <div className={`relative transition-transform ${shake ? 'shake-anim' : ''}`}>
                    <input
                        ref={inputRef}
                        type="text"
                        value={inputValue}
                        onChange={handleInput}
                        disabled={gameState !== 'playing'}
                        className={`
                            w-full bg-[#050b14] text-white font-mono text-3xl p-4 rounded border-2 
                            focus:outline-none focus:shadow-[0_0_20px_rgba(6,182,212,0.3)] 
                            text-center uppercase placeholder-slate-700 tracking-[0.2em] transition-colors duration-100
                            ${validInputFlash ? 'border-emerald-500 bg-emerald-950' : 'border-slate-600 focus:border-cyan-500'}
                        `}
                        placeholder={gameState === 'playing' ? "ENTER CODE" : "STANDBY"}
                        autoComplete="off"
                    />
                    {gameState === 'playing' && (
                        <div className="absolute right-4 top-1/2 -translate-y-1/2 text-[10px] text-slate-600 font-bold hidden sm:block pointer-events-none border border-slate-700 px-2 py-1 rounded">RET</div>
                    )}
                </div>
            </div>

            {/* Helpers Tabs */}
            {gameState === 'playing' && (
                <div className="w-full max-w-lg mt-2 flex flex-col h-[150px]">
                    <div className="flex gap-2 mb-1 px-1">
                        <button onClick={() => { setActiveHelper('bin'); focusInput(); }} className={`flex items-center gap-2 px-3 py-1 rounded-t text-xs font-bold uppercase transition-colors ${activeHelper === 'bin' ? 'bg-emerald-900 text-emerald-200 border-t border-x border-emerald-700' : 'bg-slate-800 text-slate-500 hover:bg-slate-700'}`}><Icons.Binary size={14} /> Bit Builder</button>
                        <button onClick={() => { setActiveHelper('hex'); focusInput(); }} className={`flex items-center gap-2 px-3 py-1 rounded-t text-xs font-bold uppercase transition-colors ${activeHelper === 'hex' ? 'bg-fuchsia-900 text-fuchsia-200 border-t border-x border-fuchsia-700' : 'bg-slate-800 text-slate-500 hover:bg-slate-700'}`}><Icons.Hash size={14} /> Hex Pad</button>
                    </div>
                    <div className="flex-1">
                        {activeHelper === 'bin' ? (
                            <BitHelper onUpdate={handleBitUpdate} currentVal={inputValue} onInputFocus={focusInput} />
                        ) : (
                            <HexHelper onAppend={handleHexAppend} onBackspace={handleBackspace} onClear={() => setInputValue('')} onInputFocus={focusInput} />
                        )}
                    </div>
                </div>
            )}
        </div>
    );
}
